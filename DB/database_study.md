# 데이터베이스

## 목차

- 데이터베이스 개념
- DBMS의 기능
- 스키마(Schema)
- 데이터베이스 언어
- 데이터 모델의 개념
- E-R다이어그램
- 데이터베이스 설계
- 관계형 데이터베이스의 구조
- 정규화
- SQL
- 뷰
- 시스템카탈로그
- 트랜잭션
- 트랜잭션 격리 수준
- 데이터베이스 폴
- 회복
- 병행제어
- 무결성
- 보안
- 분산 데이터베이스
- 데이터베이스의 성능
- 인덱스 (Index)
- 조인 (Join)


## 데이터베이스 개념

### 데이터베이스의 정의

- **데이터베이스**는 **특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임**
  - 통합된 데이터 : 자료의 중복 배제
  - 저장된 데이터 : 저장 매체에 저장된 자료
  - 운영 데이터 : 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료
  - 공용 데이터 : 여러 시스템들이 공동으로 소유하고 유지하는 자료




### 데이터베이스의 특징

- 실시간 접근성 : 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 한다.
- 계속적인 변화 : 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다.
- 동시 공용 : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것으로 다수의 사용자가 같은 내용의 데이터를 이용할 수 있어야 한다.
- 내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 때, 사용자가 요구하는 데이터 내용으로 데이터를 찾는다.


### 데이터베이스 시스템

- **데이터베이스 시스템**이란 **데이터베이스를 이용하여 자료를 저장하고 관리하여 정보를 얻어내는 데 필요한 컴퓨터 중심의 시스템**

- ![데이터베이스시스템구성요소](./images/데이터베이스시스템구성요소.PNG)





## DBMS의 기능

### DBMS의 정의

- **DBMS**는 사용자와 데이터베이스 사이에서 **사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어**




### DBMS의 발전 배경

- 기존 방식(**파일 시스템**) : **처리 업무 하나하나마다 데이터 파일을 독립적으로 구성**함으로써, 같은 내용의 데이터가 서로 다른 업무의 파일에서 중복저장되어 관리되는 데이터 중복성, 데이터 종속성을 초래하는 단점 존재
- **데이터베이스** 도입 : **각 업무 처리에 필요한 자료들의 중복을 최소화하여 한 곳에 모아서 구성**




### 대표적인 DBMS

- 오라클 / Oracle : PC급에서 메인프레인급까지 모두 설치할 수 있으며, 분산 처리 지원 기능이 우수
- MySQL / MySQL AB : 다양한 플랫폼과 API를 지원하는 비상업용 DBMS





### DBMS의 필수 기능

- 정의(Definiton) 기능
  - 데이터베이스에 저장될 **데이터 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시
  - 데이터와 데이터의 관계를 명확하게 명세할 수 있어야 하며, 데이터 연산은 무엇이든 명세
  
- 조작(Manipulation) 기능
  - **데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리**하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
  
- 제어(Control) 기능
  - **데이터의 무결성 유지**
  - 정당한 사용자가 허가된 데이터만 접근할 수 있도록 **보안을 유지하고, 권한을 검사**
  - 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때, 처리결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있어야 한다.
  
  
  
  
### DBMS의 장단점

| <center>장점</center> |  <center>단점</center> |
|:----------------:|:----------------:|
| 데이터의 논리적, 물리적 독립성이 보장 | 전산화 비용이 증가 |
| 데이터의 중복을 피할 수 있어서 기억공간 절약 | 대용량 디스크로의 집중적인 Access로 과부하(Overhead) |
| 저장된 자료를 공동으로 이용 | 파일의 Backup과 Recovery가 어렵다 |
| 데이터의 일관성, 무결성, 보안 유지 | 시스템이 복잡 |
| 항상 최신의 데이터 유지, 데이터의 실시간 처리 가능 |  |

  - 백업(Back up) : 장비 고장 등의 비상사태에도 데이터베이스가 보존되도록 복사하는 작업





## 스키마(Schema)

### 스키마의 정의

- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specificaion)을 기술한 메타데이터 집합
- **스키마**는 **데이터베이스를 구성하는 개체(엔티티), 속성, 관계 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의**


  ![스키마3계층](./images/스키마3계층.PNG)




### 스키마의 특징

- 스키마는 **데이터 사전**에 저장되며, 다른 이름으로 **메타데이터**라고도 한다.
- 스키마는 시간에 따라 불변인 특성을 갖는다.
- 스키마는 데이터의 구조적 특성을 의미한다.




### 스키마의 3계층

- 데이터베이스의 관리 시스템은 외부적 스키마에 따라 명시된 사용자의 요구를 개념적 스키마에 적합한 형태로 변경하고 이를 다시 내부적 스키마에 적합한 형태로 변환한다.

  - 외부 스키마 (=사용자 뷰)
    - **외부 스키마**는 **사용자나 응용 프로그래머가 각 개인의 입장**에서 필요로 하는 데이터베이스의 논리적 구조를 정의
    - 일반 사용자는 질의어(SQL)를 이용하여 DB를 쉽게 사용할 수 있다.
    - 응용 프로그래머는 C, COBOL 등의 언어를 사용하여 DB에 접근한다.
    - 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있다.
  
  - 개념 스키마 (=전체적인 뷰)
    - **개념 스키마**는 **데이터베이스의 전체적인 논리적 구조**
    - 조직 전체의 데이터베이스로 하나만 존재
    - 개념 스키마는 **개체 간의 관계와 제약 조건을 나타내고, 접근 권한, 보안 및 무결성 규칙에 관한 명세**를 정의
  - 내부 스키마 (=저장 스키마)
    - **내부 스키마**는 **물리적 저장위치의 입장에서 본 데이터베이스 구조**
    - 내부 스키마는 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.
    - 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마
    
    



## 데이터베이스 언어

- 데이터베이스 언어는 데이터베이스를 구축하고 이용하기 위한 데이터베이스 시스템과의 통신 수단
- 데이터베이스 언어는 DBMS를 통해 사용하며, 기능과 사용 목적에 따라 데이터 정의 언어, 데이터 조작 언어, 데이터 제어 언어로 구분된다.


### 데이터 정의 언어 (DDL)

- DB구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어
- 외부 스키마를 정의



### 데이터 조작 언어 (DML)

- 사용자로 하여금 데이터를 처리할 수 있게 하는 도구로서, 사용자(응용 프로그램)과 DBMS 간의 인터페이스를 제공
- 응용 프로그램을 통해서 사용자가 DB의 데이터를 실질적으로 조작할 수 있도록 하기 위해 COBOL 등의 호스트 언어에 DB 기능을 추가해서 만든 언어

  - 질의어 : 단말 사용자가 쉽게 DB를 액세스할 수 있도록 대화식의 자연어로 만든 비절차적 조작 언어 EX) SQL
  - 비절차적 조작 언어 : 사용자가 어떤 데이터가 필요한지만 명시하고 어떻게 구하는 지 명시하지 않는 언어
  
  
  

### 데이터 제어 언어 (DCL)
    
- 무결성, 보안 및 권한 제어, 회복 등을 하기 위한 언어
- 데이터를 보호하고 데이터를 관리하는 목적으로 사용



## 데이터 모델의 개념

### 데이터 모델의 정의

- **데이터 모델**은 **현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화**하여 체계적으로 표현한 개념적 모형




### 데이터 모델의 구성 요소

- 개체 : 데이터베이스에 표현하려는 것 ex) 교수
- **속성** : **데이터의 가장 작은 논리적 단위**, 개체를 구성하는 항목 ex) 성명, 전공, 소속
- 관계 : 개체 간의 관계
    - 관계의 형태 : 1대1 관계, 1대N 관계, N대N 관계
    



## E-R다이어그램


### E-R다이어그램 개념

- 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 개체들을 표현
- E-R 다이어 그램 기호
  - ![ER다이어그램기호](./images/ER다이어그램기호.PNG)
  
  
- E-R 다이어 그램 예시
  - ![ER다이어그램예시](./images/ER다이어그램예시.PNG)
  
  
- 새발 표기법
  - 관계의 의미나 제약 조건 등을 개체 타입들을 연결하는 몇 가지 기호를 사용하여 표현하는 표기법
  - ![새발표기법](./images/새발표기법.PNG)
  
  
  - 새발표기법 예시
  - ![새발표기법예시](./images/새발표기법예시.PNG)
  
  
  
  
## 관계형 데이터 모델

### 관계형 데이터 모델의 개념

- 기본키와 이를 참조하는 외래키로 데이터 간의 관계를 표현
- 1:1, 1:N, M:N 관계를 자유롭게 표현




### E-R모델을 관계 모델의 테이블로 변환

- 개체 A,B와 관계 Y로 이루어진 E-R모델을 관계 테이블로 변환하는 방법
  - ![테이블변환](./images/테이블변환.jpg)
  
  
  - 개체를 독립적인 테이블로 표현
  - 관계 Y가 **1:1관계**이면 **개체 A의 기본키를 개체 B의 외래키로 추가**하거나 **개체 B의 기본키를 개체 A의 외래키로 추가**
  - 관계 Y가 **1:N관계**이면 **개체 A의 기본키를 개체 B의 외래키로 추가**하여 표현하거나 별도의 테이블로 표현
  - 관계 Y가 **M:N관계**이면 **개체 A와 B의 기본키를 모두 포함한 별도의 테이블**로 표현
  
  
  
### 관계형 데이터 모델의 특징

- 장점 : 간결하고, 보기 편리하고, 다른 데이터베이스로의 변환이 용이
- 단점 : 성능이 떨어진다.






## 데이터베이스 설계

### 데이터베이스 설계의 개념

- **데이터베이스 설계**란 **사용자의 요구를 분석**하여 그것들을 컴퓨터에 저장할 수 있는 **데이터베이스의 구조에 맞게 변경한 후 특정 DBMS로 데이터베이스를 구현**하여 일반 사용자들이 사용하게 하는 것




### 데이터베이스 설계 시 고려사항

- 무결성 : 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함
- 일관성 : 특정 질의에 대한 응답이 끝까지 변함없이 일정해야 함
- 회복 : 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함
- 보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호
- 효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함
- 데이터베이스 확장 : 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터베이스를 추가할 수 있어야 함




### 데이터베이스 설계 순서

- 요구 분석 > 개념적 설게 > 논리적 설계 > 물리적 설계 > 구현

 
    - 요구 조건 분석 : 수집된 정보(데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건)를 바탕으로 요구 조건 명세를 작성
    - 개념적 설계 : 개념 스키마 설계, 요구 분석 단계에서 나온 결과(요구 조건 명세)를 DBMS에 독립적인 E-R다이어그램으로 작성
    - 논리적 설계 : 개념 스키마를 평가 및 정재하고 DBMS에 따라 서로 다른 논리적 스키마를 설계, 테이블을 설계
    - 물리적 설계 : 디스크 등 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환, 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정
    
    
      - 물리적 설계 옵션 시 고려 사항
        - 반응 시간 : 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을 때까지의 경과 시간
        - 공간 활용도 : 데이터베이스 파일과 액세스 경로 구조에 의해 사용되는 저장공간의 양
        - 트랜잭션 처리량 : 단위시간 동안 데이터베이스 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수
        
    - 데이터베이스 구현 : DDL로 데이터베이스 생성, 트랜잭션 




## 관계형 데이터베이스의 구조

### 관계형 데이터베이스의 릴레이션 구조

- ![관계형데이터베이스릴레이션구조](./images/관계형데이터베이스릴레이션구조.PNG)


- 튜플(Tuple) : 릴레이션을 구성하는 각각의 행, 파일 구조에서 레코드와 같은 의미
  - **튜플의 수** : **카디날리티**
  
- 속성(Attribute) : 데이터베이스를 구성하는 가장 작은 논리적 단위
  - **속성의 수** : 디그리, 차수
  
- 도메인 : 하나의 속성(Attribute)이 취할 수 있는 같은 타입의 원자값들의 집합
  - ex) 성별 애트리뷰트의 도메인은 '남'과 '여'로, 그 외의 값은 입력될 수 없다.
  > 도메인의 역할 : 데이터베이스에 입력되는 자료의 오류를 방지하기 위해 필요
  
  
  
### 릴레이션의 특징

- 한 릴레이션에는 똑같으 튜플이 포함될 수 없다.
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 지정한다. ex) '학년'에 저장된 1,2,3은 더 이상 세분화 X




## 관계형 데이터베이스의 제약 조건

### 제약 조건이란?

- 데이터베이스에 저장되는 데이터의 정확성을 보장하기 위해서 키를 이용하여 입력되는 데이터에 제한을 주는 것
- ex) 개체 무결성 제약, 참조 무결성 제약 등



### 키의 개념 및 종류

- **키(Key)** : 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 **튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트**

- **유일성** : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
- **최소성** : 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 한다.

  - 후보키 : 기본키로 사용할 수 있는 속성들, 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.
  - 기본키 : 특정 튜플을 유일하게 구별할 수 있는 속성, NULL값 가질 수 없음, 동일한 값 중복 X
    - ex) <학생>릴레이션에서는 '학번', '주민번호'가 기본키가 될 수 있다.
  - 대체키 : 후보키가 둘 이상일 때, 기본키를 제외한 후보키
  - 슈퍼키 : 모든 튜플들에 대해서 유일성은 만족시키지만, 최소성은 만족시키지 못한다.
    - ex) <학생>릴레이션에서는 '학번', '주민번호', '학번+주민번호', '주민번호+성명', '학번+주민번호+성명' 등으로 슈퍼키를 구성할 수 있다.
    
  - 외래키 : 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는 키
  
  
  
### 무결성

- **개체 무결성** : 릴레이션에서 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없다.
- **참조 무결성** : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다.




## 정규화

### 정규화란

- **정규화** : 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 좀 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정

- 정규화는 데이터베이스의 논리적 설계 단계에서 수행한다.
- 정규화는 논리적 처리 및 품질에 큰 영향을 미친다.




### 정규화 목적

- 데이터 구조의 안정성을 최대화한다.
  - 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다.
  - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
- 효과적인 검색 알고리즘을 생성할 수 있다.



### 함수 종속

- X가 Y를 결정한다. X는 Y의 결정자
- X : 결정자, Y : 종속자


- ![함수종속예제](./images/함수종속예제.png)

- ex) {학번, 과목번호} -> {성적} : 완전 함수 종속
- ex) {학번} -> {학년} : 부분 함수 종속




### 이상의 개념 및 종류

- **이상** : 정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생
- ex) 삽입 이상, 삭제 이상, 갱신 이상 등


  - 삽입 이상 : 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상
  - 삭제 이상 : 한 튜플을 삭제할 때 의도와는 상과없이 원하지 않는 값들도 함께 삭제되는 현상
  - 갱신 이상 : 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상




### 정규화 과정

- 일반적으로 데이터베이스를 설계할 때에는 BCNF까지만 고려
  > 정규화 과정을 거칠수록 join 연산으로 인한 성능저하를 가져올 수 있기 때문에
  > 단계 진행할수록 데이터의 무결성을 우선으로 할 지 데이터베이스 구성의 단순화와 성능을 우선으로 할 지를 결정
  
  
- ![정규화과정](./images/정규화과정.png)


  - 제1정규형 (1NF) : 어떤 릴레이션 R에 속한 모든 도메인이 원자값만으로 되어 있다.
  
  - ![제1정규화](./images/제1정규화.PNG)
  
  - 제2정규형 (2NF) : 어떤 릴레이션 R이 제 1정규형이고, 키에 속하지 않는 속성 모두가 키에 완전 함수 종속 : 무손실분해
  
  - ![제2정규화](./images/제2정규화.PNG)
  - ![제2정규화2](./images/제2정규화2.PNG)
  
    > 학번은 혼자 스스로 잘할 수 있지만, 과목명은 혼자 스스로 잘할 수 없으니까 학번이랑 같이 있어야함.
    
    
  - 제3정규형 (3NF) : 어떤 릴레이션 R이 2NF이고, 모든 속성들이 기본키에 이행적 함수 종속이 아닌 경우
    - 이행적 함수 종속성 : A->B와 B->C의 함수 종속성이 존재하면 A->C (속성 C가 이행적으로 A에 종속)
    
  - ![제3정규화](./images/제3정규화.PNG)
  
  - ![제3정규화2](./images/제3정규화2.PNG)
  
    > 결정자 X -> 종속자 Y : 결정자 X가 개수가 더 많다고 생각했더니 이해가 되었다. X가 Y에 포함이 되는 경우.
   
  
  - BCNF : 릴레이션 R이 제 3정규형이고, 모든 결정자가 후보키이어야 한다.
  
  - ![BCNF](./images/BCNF.PNG)
  
  - ![BCNF2](./images/BCNF2.PNG)
  
  
## SQL

### SQL이란?

- 질의어지만 질의 기능만 가지고 있는 것이 아니라 데이터 구조의 정의, 데이터 조작, 데이터 제어 기능을 모두 갖추고 있다.
  > 질의어 : 단말 사용자들이 쉽게 DB를 이용할 수 있도록 되어 있는 비절차어의 일종
  
  
### SQL의 분류

- DDL (데이터 정의어)
  - CREATE
    
    - CREATE SCHEMA (스키마 정의)
    ```sql
    
    // 소유권자의 사용자 ID가 홍길동인 스키마 '대학교' 정의문
    CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;
    
    ```

    - CREATE DOMAIN (도메인 정의)
    ```sql
    
    // '남', '여' 또는 '?'중의 한 문자를 취할 수 있는 도메인 SEX의 정의문
    CREATE DOMAIN SEX CHAR(1) // 정의된 도메인 이름은 'SEX'이며, 크기는 1자 
      DEFAULT '여' // 기본값 '여'
      CONSTRAINT VALID-SEX CHECK(VALUE IN ('남', '여', '?'));   //  3개의 값 중 하나만 취하도록 제한
    
    ```
    
    - CREATE TABLE (테이블 정의)
    
    ```sql
    
    CREATE TABLE 학생
      (이름 VARCHAR(15) NOT NULL,
      학번 VARCHAR(15) NOT NULL,
      전공 VARCHAR(15) NOT NULL,
      성별 SEX,   // 앞에서 정의한 도메인
      생년월일 DATE,
      PRIMARY KEY(학번),
      FOREIGN KEY(전공) REFERENCES 학과(학과코드),  // '전공'은 '학과' 테이블의 '학과코드' 속성을 참조하는 외래키
      CONSTRAINT 성별제약 CHECK (성별='남')         // '성별' 속성의 값으로 '남'만 저장할 수 있게 제약
      );
    
    ```
    
    - CREATE INDEX (인덱스 정의)
    
    ```sql
    
    // '고객' 테이블의 기본키인 '고객번호' 속성에 대해 오름차순 정렬하여 '고객번호_INX'라는 이름으로 인덱스 구성
    
    CREATE UNIQUE INDEX 고객번호_INX
      ON 고객(고객번호 ASC);
    
    ```
    
  - ALTER
  
    - ALTER TABLE (테이블 정의 변경)
    
    ```sql
    
    // '학생' 테이블에 최대 3문자로 구성되는 '학년'속성 추가
    
    ALTER TABLE 학생 ADD 학년 VARCHAR(3);
    
    ```
    
  - DROP
  
    - DROP TABLE (테이블 삭제)
    > CASCADE : 삭제할 요소를 참조하는 다른 모드 개체 함께 삭제
    > RESTRICTED : 삭제할 요소를 다른 개체가 참조중일 때 삭제 취소
    
    ```sql
    
    // '학생' 테이블을 삭제하되, '학생' 테이블을 참조하는 모든 테이블을 함께 삭제
    DROP TABLE 학생 CASCADE;
    
    ```
  

- DML

  - SELECT
    - 일반 형식
    > ASC : 오름차순
    > DESC : 내림차순
    > 생략시 오름차순
    
    ```sql
    
    SELECT [DISTINCT] 속성명
    FROM 테이블명
    WHERE 조건
    GROUP BY 속성명
    HAVING 조건
    ORDER BY 속성명 [ASC|DESC];
    
    ```
  
    ```sql
    
    // <사원> 테이블에서 주소만 검색하되 같은 주소는 한 번만 출력
    SELECT DISTINCT 주소 FROM 사원;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 기본급에 특별수당 10을 더한 월급을 "XX부서의 XXX의 월급 XXX"형태로 출력
    SELECT 부서, "부서의", 이름, "의 월급", 기본급+10 FROM 사원
    
    // 신기한 건 "부서의", "의 월급"이 사이 사이에 위치한다. 튜플마다 전부!
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 성이 '김'인 사람의 튜플을 검색
    SELECT * FROM 사원 WHERE 이름 LIKE "김%";
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 생일이 '01/09/69'에서 '10/22/73' 사이인 튜플을 검색
    SELECT * FROM 사원 WHERE 생일 BETWEEN #01/09/69# AND #10/22/73#;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 주소가 NULL인 튜플을 검색
    SELECT * FROM 사원 WHERE 주소 IS NULL;
    
    ```
    
    ```sql
   
     // <사원> 테이블에서 특정 인덱스 몇명을 검색
     SELECT * FROM 사원 LIMIT [시작할 로우 0부터 시작], [보여줄 개수];
   
     ex) SELECT * FROM 사원 LIMIT 32, 3; // 32번 인덱스부터 3명 보여주기
   
    ```
    
    ```sql
    
    // <사원> 테이블에서 주소를 기준으로 오름차순 정렬시켜서 상위 2개의 튜플만 검색
    SELECT TOP 2 * FROM 사원 ORDER BY 주소 ASC;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 부서별 기본급의 평균
    SELECT 부서, AVG(기본급) AS 평균
    FROM 사원 GROUP BY 부서;
    
    ```
    
    
    ```sql
    
    // <사원> 테이블에서 기본급이 100 이상인 사원이 2명 이상인 부서의 튜플 수
    SELECT 부서, COUNT(*) AS 사원수
    FROM 사원
    WHERE 기본급 >= 100
    GROUP BY 부서
    HAVING COUNT(*)>=2;
    
    ```
    
    ```sql
    
    // 취미가 '나이트댄스'인 사원의 이름과 주소를 검색
    SELECT 이름, 주소 FROM 사원
    WHERE 이름 = (SELECT 이름 FROM 여가활동 WHERE 취미='나이트댄스');
    
    ```
    
    ```sql
    
    // 취미활동을 하지 않는 사원들을 검색
    SELECT * FROM 사원
    WHERE 이름 NOT IN (SELECT 이름 FROM 여가활동)
    
    ```
    
    ```sql
    
    // 경력이 10년 이상인 사원의 이름, 부서, 취미, 경력을 검색
    SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력
    FROM 사원, 여가활동
    WHERE 여가활동.경력>=10 AND 사원.이름=여가활동.이름;
    
    ```
    
    ```sql
    
    // <사원>테이블과 <직원>테이블을 통합하는 질의문
    SELECT * FROM 사원
    UNION
    SELECT * FROM 직원;
    
    ```
    
    
  - INSERT
  
    ```sql
    
    // <사원> 테이블에 (이름-홍승현, 부서-인터넷)을 삽입하시오
    INSERT INTO 사원(이름, 부서) VALUES ('홍승현', '인터넷');
    
    ```
    
    ```sql
    
    // <사원> 테이블에 (장보고, 기획, 05/03/73, 석사동, 90)을 입력하시오
    INSERT INTO 사원 VALUES ('장보고', '기획', #05/03/73#, '석사동', 90);
    
    ```
    
    ```sql
    
    INSERT INTO 편집부원(이름, 생일, 주소, 기본급)
    SELECT 이름, 생일, 주소, 기본급
    FROM 사원
    WHERE 부서='편집';
    
    ```
    
  - UPDATE
  
    ```sql
    
    // <사원> 테이블에서 홍길동의 주소를 퇴계동으로 수정
    UPDATE 사원 SET 주소 = '퇴계동' WHERE 이름 = '홍길동';
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 황진이의 부서를 기획부로 변경하고 기본급을 5만우너 인상
    UPDATE 사원 SET 부서='기획', 기본급=기본급+5
    WHERE 이름='황진이';
    
    ```
    
  - DELETE
    
    ```sql
    
    // <사원> 테이블의 모든 레코드를 삭제
    DELETE FROM 사원;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 임꺽정에 대한 튜플을 삭제
    DELETE FROM 사원 WHERE 이름 = '임껵정';
    
    ```
    
    
- DCL
  - COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알린다.
  - ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구한다.
  - GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.
  - REVOKE : 데이터베이스 사용자의 사용 권한을 취소한다.
  
  
## 뷰 (View)

### 뷰란?

- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가진 가상 테이블

- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게 있는 것처럼 간주


### 뷰의 장단점

- 장점
  - 사용자의 데이터 관리 간단화
  - 접근 제어를 통한 자동 보안 제공
  - 논리적 데이터 독립성을 제공
  
- 단점
  - 독립적인 인덱스를 가질 수 없다
  - 뷰의 정의를 변경할 수 없다
  - 뷰로 구성된 애용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다
  
  

### 뷰의 정의 및 삭제문

- 정의

  ```sql
  // 고객테이블에서 주소가 춘천시인 고객들의 성명과 전화번호로 '춘천고객'이라는 뷰 정의
  
  CREATE VIEW 춘천고객(성명, 전화번호)
  AS SELECT 성명, 전화번호
  FROM 고객
  WHERE 주소='춘천시'
  ```
  
  
- 삭제
  ```sql
    
    // 뷰 '춘천고객'을 삭제하시오. 단 다른 곳에서 참고하고 있으면 제거되지 않게 하시오.
    DROP VIEW 춘천고객 RESTRICT;
    
    ```



## 시스템 카탈로그

### 시스템 카탈로그란?
- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 데이터 정의어의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 패키지, 접근 권한 등의 데이터베이스 구조 및 통계 정보를 저장
- 카탈로그에 저장된 정보를 메타 데이터라고 한다.
- 카탈로그는 DBMS가 스스로 생성하고 유지한다.
- 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신한다.
  
  
### 트랜잭션 처리기

- DBMS 내의 모듈 시스템
- 복수 사용자 환경에서 평행으로 동시에 일어나는 트랜잭션 문제를 해결하여, 각각의 사용자가 데이터베이스 자원을 배타적으로 이용할 수 있도록 한다.
  



## 트랜잭션

### 트랜잭션의 정의

- **트랜잭션이란**, 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위를 의미한다.
- 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.
- 하나의 트랜잭션은 Commit되거나 Rollback된다.


- ex) 부모님 계좌에서 10만원을 인출해서 자식 계좌에 10만원을 입금해보자 -> 한꺼번에 모두 수행되엉야 할 일련의 연산들 (트랜잭션)

- ![트랜잭션](./images/트랜잭션.jpeg)



### 트랜잭션의 특징 (ACID)

- Atomicity (원자성)
  - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 한다.
  - 트랜잭션의 모든 연산들은 데이터베이스에 정상적으로 모두 수행되거나, 모두 취소되어야 한다.


- Consistency (일관성)
  - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.


- Isolation (독립성)
  - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
  
  
- Durability (지속성, 영속성)
  - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
  

- ![트랜잭션특징](./images/트랜잭션특징.jpeg)



### 트랜잭션의 연산

- Commit 연산
  - 한 개의 논리적 단위(트랜잭션)에 대한 자겅비 성공적으로 끝난 상태
  - 트랜잭션이 수행한 내용을 데이터베이스에 반영함 (지속성, 영속성)
  - ![commit](./images/commit.jpeg)


- Rollback 연산
   - 트랜잭션을 성공적으로 처리하지 못하여 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산
   - 트랜잭션 내에서 수행한 내용이 데이터베이스에 일부 반영이 되었다 하더라도 모두 취소하거나 트랜잭션을 재시작해야 함
   
   - ![rollback](./images/rollback.jpeg)



### 트랜잭션의 상태

- ![transaction_status](./images/transaction_status.jpeg)
- 활동 : 트랜잭션이 실행 중인 상태
- 실패 : 트랜잭션 실행에 오류가 발생하여 중단된 상태
- 철회 : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
- 부분 완료 : Commit 요청이 들어왔을 때의 상태
- 완료 : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태



### 트랜잭션을 사용할 때 주의할 점
- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화하라는 의미
- 일반적으로 데이터베이스 커넥션의 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션 개수는 줄어들 것이다.
- 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있다.


### 교착상태

  - 교착상태란?
    - 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태
    
  - 교착 상태의 예(MySQL)
    - MySQL MVCC에 따른 특성 때문에 트랜잭션에서 갱신 연산(INSERT, UPDATE, DELETE)를 실행하면 잠금을 획득한다. (기본은 행에 대한 잠금)
    
    - ![트랜잭션_교착상태](./images/트랜잭션_교착상태.PNG)
    
    ```sql
    
    // 트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고, 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다.
    
    Transaction 1> create table B (i1 int not null primary key) engine=innodb;
    Transcation 2> create table A (i1 int not null primary key) engine=innodb;
    
    Transaction 1> start transaction; insert into B values(1);
    Transcation 2> start transaction; insert into A values(1);
    
    ```
    
    ```sql
    
    // 트랜잭션을 commit 하지 않은 채 서로의 첫번째 행에 대한 잠금을 요청 시 발생하는 에러
    Transaction 1> insert into A values(1);
    Transaction 2> insert into B values(1);
    ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
    
    ```

    - Deadlock이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.
    
    
## 트랜잭션 격리 수준 (Isolation Level)

### Isolation Level이란?

- 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준


### Isolation Level의 필요성

- 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서 독립적인 수행을 하도록 한다.
- 그래서 Locking 이라는 개념이 등장한다.
  > Locking : 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것
- 하지만 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능이 떨어진다.
- 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리될 여지가 있다.
- 그래서 상황에 따라 최대한 효율적인 Locking 방법이 필요하다.


### Isolation Level의 종류

- Read Uncommitted (레벨 0)
  - SELECT문이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level
  - 트랜잭션에 처리중인 혹은 아직 commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
  - ex) 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
  - 데이터베이스의 일관성을 유지할 수 없다.


- Read Committed (레벨 1)
  - SELECT 문이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level
  - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기
  - Commit이 이루어진 트랜잭션만 조회할 수 있다.
  - ex) 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.
  - SQL Server가 Default로 사용하는 Isolation level
  
  
- Repeatable Read (레벨 2)
  - 트랜잭션이 완료될 때까지 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능
  - UPDATE는 불가능하지만 INSERT는 가능.
  - 동일 트랜잭션에서 Read되는 데이터 수가 달라질 수 있다.
  
  
- Serializable (레벨 3)
  - 트랜잭션이 완료될 때까지 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능
  - 해당 레벨에서는 INSERT 작업도 허용하지 않음
  

- **결론** : Isolation level 조정은 동시성이 증가되는 데 반해 데이터 무결성에 문제가 발생할 수 있고, 데이터 무결성을 유지하면 동시성이 떨어질 수 있습니다.



### 낮은 단계의 Isolation Level 이용 시 발생하는 현상

![isolation-level](./images/isolation-level.png)

- Dirty Read : 어떤 트랜잭션에서 아직 실행이 끊나지 않은 다른 트랜잭션에 의한 변경사항을 보게 되는 경우 

- Non-Repeatable Read : 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션의 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 다르게 나타나는 형상 (트랜잭션 도중 새로운 레코드 삽입 및 수정 허용해서 나타나는 현상)

- Phantom Read : 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 읽은 결과가 다른 현상 (트랜잭션 도중 새로운 레코드 삽입 허용해서 나타나는 현상)




## 데이터베이스 풀

### 데이터베이스 풀이란?

- Connection Pool
  - 클라이언트의 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 Connection이 필요하다
  - Connection pool은 이런 Connection을 여러 개 생성해두어 저장해놓은 공간(캐시), 또는 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법을 말한다.
  
  - ![DBconnectionpool](./images/connectionpool.png)

- DB에 접근하는 단계
  - 첫째) 웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장한다.
  - 둘째) DB에 요청 시, pool에서 Connection 객체를 가져와서 DB에 접근한다.
  - 셋째) 처리가 끝나면 다시 pool에 반환한다.
  
  - ![DBconnectionpool2](./images/connectionpool2.jpeg)


### Connection이 부족할 경우, 필요한 이유

- Connection이 부족하면?
  - 모든 요청이 DB에 접근하고 남은 Connection이 없다면, 해당 클라이언트는 대기 상태로 전환시키고 pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공된다.
  
- 왜 사용할까?
  - 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다.
  - 미리 생성된 Connection 객체를 사용하기 때문에 DB 접근 시간이 단축된다.
  - DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있다.
  

### Thread Pool / Connection Pool

- Thread Pool
  - 매 요청마다 요청할 처리할 Thread를 만드는 것이 아니라 Connection Pool과 마차가지로 미리 생성된 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법
  
- Thread Pool vs Connection Pool
  - WAS 에서 Thread pool과 Connection pool 내의 Thread와 Connection 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면 서버에서는 많은 요청을 처리하지 못하고 대기할 수 밖에 없다.
  
  - 보통 WAS의 thread 수가 Conncetion 수보다 많은 것이 좋다. 그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.
  
  

    
    
    
## 회복

### 회복의 정의

- 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업
- 회복 관리기 : DBMS의 구성요소, 트랜잭션 실행이 성공적으로 완료되지 못하면 트랜잭션이 데이터베이스에 생성했던 모든 변화를 취소(Undo)시키고, 트랜잭션 수행 이전의 원래 상태로 복구하는 역할을 담당
- 회복 관리기는 메모리 덤프, 로그를 이용하여 회북 수행
  > 덤프 : 주기적으로 데이터베이스 전체를 복사
  > 로그 : 갱신되기 전후의 내용을 기록하는 별도의 파일
  



## 병행제어

### 병행제어의 정의

- 다중 프로그래밍의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것



### 병행제어의 목적

- 데이터베이스의 공유 최대화
- 시스템의 활용도 최대화
- 데이터베이스의 일관성 유지
- 사용자에 대한 응답시간 최소화

> 다중 프로그래밍 환경에서 여러 개의 트랜잭션을 병행 수행한다는 것은 같은 시간에 여러 개의 명령을 동시에 실행하는 것이 아니라 **시분할이나 입출력 인터럽트 기법 등을 이용**하여 **일정한 시간 내에 각 트랜잭션에 있는 명령들이 시간적으로 번갈아 실행**되는 것이다.



### 병행제어기법 사용안할 때 생기는 문제점

- 갱신 분실 : 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상

- 비완료 의존성 : 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상

- 모순성 : 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제

- 연쇄 복귀 : 병행수행하던 트랜잭션들 중 어느 하나에 문제가 생겨 Rollback하는 경우 다른 트랜잭션도 함께 Rollback되는 현상



### 병행제어 기법의 종류

- 로킹
  - 로킹의 목적 : 주요 데이터 액세스를 상호 배타적으로 하는 것
  - 로킹 : 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법
  
  > 로킹 단위 : 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기 ex) 데이터베이스, 파일, 레코드, 필드 등
  > Lock을 나는 이렇게 이해를 하였다. 운영체제에서 자원을 선점한다는 것으로 이해를 하였다. 선점하기 전에 요청을 해야하고 허락받으면 자원을 할당받는 것이다.


- 2단계 로킹 규약
  - 각 트랜잭션의 로크 요청과 해제(Unlock)요청을 2단계로 실시
  - 직렬성을 보장하는 장점이 있지만, 교착상태를 예방할 수 없다는 단점이 있음
  
  
- 타임 스탬프 순서
  - 트랜잭션 간의 처리 순서를 미리 선택하는 기법
  - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
  - 교착 상태가 발생하지 않음
  
  
  
## 무결성

### 무결성이란

- 데이터베이스에 저장된 데이터 값과 그것이 표현되는 현실 세계의 실제값이 일치하는 정확성을 의미


### 무결성의 종류

- 널 무결성 : 릴레이션의 속성값이 NULL이 될 수 없도록 하는 규정

- 고유 무결성 : 릴레이션의 속성에 대해서 각 튜플이 갖는 값들이 서로 달라야 한다는 규정

- 참조 무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정

- 도메인 무결성 : 특정 속성의 값이 정의된 도메인에 속한 값이어야 한다는 규정

- 키 무결성 : 하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정

- 개체 무결성 : 테이블의 기본키를 구성하는 어떤 속성도 NULL값이나 중복값을 가질 수 없다는 규정



## 보안

### 데이터베이스 보안의 의미

- 데이터베이스의 일부분 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술


### 보안 vs 무결성

- 무결성은 권한이 있는 사용자로부터 데이터베이스를 보호하는 것이고, 보안은 권한이 없는 사용자로부터 데이터베이스를 보호하는 것

- 보안은 데이터베이스 사용자들이 데이터베이스를 사용하고자 할 때 언제든지 사용할 수 있도록 보장하는 것이고, 무결성은 정확하게 사용할 수 있도록 보장하는 것이다.


### 권한 부여 기법

- GRANT / REVOKE
- 사용자 등급 지정 및 해제
  - 사용자 등급의 종류
    - DBA : 데이터베이스 관리 책임자
    - RESOURCE : 데이터베이스 및 테이블 생성 가능자
    - CONNECT : 단순 사용자
    
  ```sql
  
  // 사용자 ID가 KORA인 사람에게 데이터베이스 및 테이블을 생성할 수 있는 권한을 부여
  GRANT RESOURCE TO KORA;
  
  ```
  
  ```sql
  
  // 사용자 ID가 STAR인 사람에게 단순히 데이터베이스에 있는 정보를 검색할 수 있는 권한만 부여
  GRANT CONNECT TO STAR;
  
  ```

- 테이블 및 속성에 대한 권한 부여 및 취소

  - 권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE, INDEX, ALTER 등
  - WITH GRANT OPTION : 다른 사용자에게 다시 부여할 수 있는 권한 부여
  - GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소
  - CASCADE : 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 제한
  
  ```sql
  
  // 사용자가 ID가 JULIA인 사람에게 고객 테이블에 대한 모든 권한과 다른사람에게 권한을 부여할 수 있는 권한까지 부여
  GRANT ALL ON 고객 TO JULIA WITH GRANT OPTION;
  
  ```
  
  
  ```sql
  
  // 사용자 ID가 JULIA인 사람에게 부여한 권한 중 갱신(UPDATE) 권한을 취소
  REVOKE UPDATE ON 고객 FROM JULIA;
  
  ```
  
  ```sql
  
  // 사용자가 ID가 JULIA인 사람에게 부여한 권한 중 다른사람에게 갱신(UPDATE) 권한을 부여할 수 있는 권한을 취소
  REVOKE GRANT IPTION FOR UPDATE ON 고객 FROM JULIA;
  
  
  ```
  
  
  
## 분산 데이터베이스


### 분산 데이터베이스란?

- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스

- 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에 해결될 수 있도록 한다.


### 분산 데이터베이스 설계 시 고려사항

- 작업부하의 노드별 분산 정책
- 데이터의 일관성 정책
-사이트나 회선의 고장으로부터 회복 기능
- 통신 네트워크를 통한 원격 접근 가능




### 미들웨어

- 분산 환경에서 구성원들을 연결하고 구성원들의 차이를 극복하도록 범용으로 개발된 소프트웨어
- 클라이언트와 서버 사이에 존재하면서 다중 통신, 데이터 액세스 프로토콜과 인터페이스 등을 지원
  - 미들웨어의 종류
  
    - 통신 미들웨어 : NOS (Network Operating System)
    - 데이터베이스 미들웨어 : ODBC
    - 분산 객체 미들웨어 : CORBA, DCOM
    
    

## 데이터베이스의 성능

- 데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다.
  - 디스크 I/O란, 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.
  - 디스크의 성능은 디스크 헤더의위치를 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.
  
 - 그렇기 때문에 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분이 랜덤 I/O이다.
 - 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
 
 
 
 
## 인덱스
 
### 인덱스란?
 
 - 대용량의 데이터(레코드)가 있을 때, 특정 데이터를 검색하기 위해서 테이블의 레코드를 full scan하는 것이 아니라, **인덱스가 적용된 컬럼의 테이블(컬럼, 인덱스주소)을 따로 파일로 저장해놓고 그것을 검색해서 검색 효율을 높이는 방법**
 
 
 
### 인덱스의 특징

- 인덱스는 범위 스캔(Range scan)을 한다. (=인덱스는 키 컬럼순으로 정렬되어 있기때문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다.)

 
 
 
### B-tree

- 인덱스에 가장 많이 사용되는 구조
- B-tree = 균형 잡힌 트리 라고도 한다. (leaf block의 깊이가 모두 동일하여서)
- 또한, 각 노드에 값도 가지고 있다. (B+tree는 값은 없고 탐색을 위한 인덱스 정보만 있다)

- [!B_tree](./images/B_tree.PNG)
  > 위의 그림은 B+트리임! B-tree는 leaf node가 이중연결리스트로 연결되어 있지 않음. 

- B-tree 구성 방법 (찾고 있음)

  - 대기 중 / 아지즈교수님 자료 찾아봐야함
  
  
  
### 인덱스의 성능과 고려해야할 사항

- 인덱스는 SELECT문의 where, join에서 좋은 성능을 발휘하지만, INSERT, UPDATE, DELETE문에서 성능이 떨어진다.
  > INSERT문의 경우 새로운 데이터를 삽입하면서 테이블뿐만 아니라 인덱스 테이블에도 생성을 해줘야 하며, 만약 인덱스의 leaf block이 꽉찼는데 그 사이에 값이 들어온다면 다른 block으로 밀려나야할 데이터가 생기고, 새로운 블럭에 값을 옮길 때 모든 과정이 redo에 기록되는 일이 생긴다.
  
  > DELETE문은 기존 테이블에서는 그냥 레코드를 삭제하고 그 공간을 다른 레코드가 사용할 수 있지만 인덱스 테이블은 사용 안함 표시만 하고 자리를 그대로 차지하기 때문에 많이 사용하면 메모리가 커진다.
  
  > UPDATE문은 DELETE하고 INSERT하는 방식으로 처리하기 때문에 부하가 더 많아진다.
  
- **결론** : 인덱스는 **검색(SELECT)이 많고, INSERT, UPDATE, DELETE문이 적게 일어나는 테이블**에서 사용하는 것을 추천

- 인덱스를 적용할 컴럼은 분포도가 좋아야 한다. (=골고루 유일성을 갖게 분포)
  - ex) 이름, 나이, 성별 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까?
  - 이름에 대해서만 인덱스를 생성하는 것이 효율적이다.   
  



## NoSQL

### NoSQL란?

- 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소




### NoSQL 특징 (CAP)

- 일관성 (Consistency)
 - 일관성 : 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 돌이한 데이터임을 보증
 - 각 NoSQL들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법을 사용
  - 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법 (시간 오래 걸림, 정확성 보장)
  - 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법 (응답시간 빠름, 데이터 손실 발생할 수 있음)
  
  
- 가용성 (Availability)
  - 가용성 : 모든 클라이언트의 읽기와 쓰기 요청에 대해서 항상 응답이 가능해야 함을 보장
  - NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능
  - 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나더라도 데이터 유실되지 않도록 하는 방법
 

- 네트워크 분할 허용성 (Partition tolerance)
  - 분할 허용성 : 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미



### 저장방식에 따른 NoSQL 분류

- Key-Value Model
  - 하나의 키에 데이터 하나를 저장하고 조회
  - 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정확성을 보장할 수 없다
  - ex) Redis, 사용자의 프로필 정보, 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 
  
- Document Model
  - 하나의 키에 하나의 구조화된 문서를 저장하고 조회
  - 키는 문서에 대한 ID로 포현되며, 문서 ID에 대한 인덱스 생성이 가능하다.
  - 문서 ID에 대한 인덱스를 사용하여 O(1) 시간안에 문서 조회 가능
  - ex) MongoDB, 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용


- Column Model
  - 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회
  - 모든 컬럼은 항상 타임 스탬프 값과 함께 저장
  - 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공
  - ex) 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현

 


## 조인 (Join)

### 조인이란?

- 한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것

### 조인의 필요성

- 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고, 각 테이블끼리는 관계를 갖게 된다.

- 이와 같은 특징으로 관계형 데이터베이스는 저장 공간의 효율성과 확장성이 향상되게 한다.
- **서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요**하다.


![join-table](./images/join-table.png)


### 조인의 종류

- 내부 조인 (INNER JOIN)
  - 2개의 테이블(A,B)의 컬럼 값을 결합함으로써 새로운 결과 테이블을 생성
  - 명시적 조인 표현
  ```sql
  
  SELECT * FROM employeeINNER JOIN deparment 
  ON employee.DepartmentID = department.DepartmentID;
  
  ```
  
  -암시적 조인 표현
  ```sql
  
  SELECT * FROM employee, department
  WHERE employee.DepartmentID = department.DepartmentID;
  
  ```
  
  - 결과
  ![inner-join](./images/inner-join.png)
  
  
    - 동등 조인 (EQUAL JOIN)
      - 비교자 기반의 조인이며, 조인 구문에서 동등비교만을 사용
      
    - 자연 조인 (NATURAL JOIN)
      - 동등 조인의 한 유형으로 조인된 테이블에서 동일한 컬럼명을 가진 2개의 테이블에서 모든 컬럼들을 비교함으로써 암시적으로 일어나는 구문
      - 결과적으로 나온 조인된 테이블은 동일한 이름을 가진 컬럼의 각 쌍에 대한 단 하나의 컬럼만 포함 (DepartmentID가 겹치는 데 하나의 컬럼으로 표시하였다는 것을 알 수 있음)
      
      ![natural-join](./images/natural-join.png)
      
      
    - 교차 조인 (CROSS JOIN)
      - 조인되는 두 테이블에서 곱집합을 반환
      - 즉, 두 번째 ㅔ이블로부터 각 행과 첫 번째 테이블에서 각 행이 한 번씩 결합된 열을 만드는 것
      - 명시적 조인 표현
      ```sql
      
      SELECT * FROM employee
      CROSS JOIN department
      
      ```
      
      - 암시적 조인 표현
      
      ```sql
      
      SELECT * FROM employee, departemtn
      
      ```
      
      - 결과
      ![cross-join](./images/cross-join.png)
      
      
  
- 외부 조인 (OUTER JOIN)
  - 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에서 외부 조인을 활용하여 효과적으로 결과 집합을 생성할 수 있다.
  
  - 왼쪽 외부 조인 (LEFT OUTER JOIN)
    - 좌측 테이블의 모든 데이터를 포함하는 결과 집합을 생성
    
    ```sql
    
    SELECT * FROM employee LEFT OUTER JOIN department
    ON employee.DepartmentID = department.DepartmentID;
    
    ```
    
    - 결과
    ![left-outer-join](./images/left-outer-join.png)
    
    
  - 오른쪽 외부 조인 (RIGHT OUTER JOIN)
    - 우측 테이블의 모든 데이터를 포함하는 결과 집합을 생성
    
    ```sql
    
    SELECT * FROM employee RIGHT OUTER JOIN department
    ON employee.DepartmentID=department.DepartmentID;
    
    ```
  
    - 결과
    
    ![right-outer-join](./images/right-outer-join.png)
    
    
  - 완전 외부 조인 (FULL OUTER JOIN)
    - 양쪽 테이블 모두 OUTER JOIN이 필요할 때 사용
    
    ```sql
    
    SELECT * FROM employee FULL OUTER JOIN department
    ON employee.DepartmentID = department.DepartmentID;
    
    ```

    - 결과
    ![full-outer-join](./images/full-outer-join.png)
    
- 셀프 조인 (SELF JOIN)
  - 한 테이블에서 자기 자신에 조인시키는 것
  
  
### 조인을 사용할 때 주의사항

- SQL 문장의 의미를 제대로 파악
  - SQL을 어떻게 작성하느냐에 따라 성능이 크게 좌우된다.
  
- 명확한 조인 조건 제공
  - 조인 조건을 명확하게 제공하지 않을 경우, 의도치 않게 CROSS JOIN이 수행될 수 있다.
  
  
### 조인을 사용할 때 고려사항

- 조인할 대상의 집합을 최소화
  - 집합을 최소화할 방법이 있으면, 조건을 먼저 적용하여 관계를 맺을 집합을 최소화한 후, 조인을 맺는 것이 효율적이다.
  
  
- 효과적인 인덱스의 활용
  - 인덱스를 활용하면 조인 연산의 비용을 극적으로 낮출 수 있다.















