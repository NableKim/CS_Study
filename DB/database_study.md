# 데이터베이스

## 목차

- 데이터베이스 개념
- DBMS의 기능
- 스키마(Schema)
- 데이터베이스 언어
- 데이터 모델의 개념
- E-R다이어그램
- 데이터베이스 설계
- 관계형 데이터베이스의 구조
- 정규화
- SQL
- 뷰
- 시스템카탈로그



- 데이터베이스의 성능


## 데이터베이스 개념

### 데이터베이스의 정의

- **데이터베이스**는 **특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임**
  - 통합된 데이터 : 자료의 중복 배제
  - 저장된 데이터 : 저장 매체에 저장된 자료
  - 운영 데이터 : 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료
  - 공용 데이터 : 여러 시스템들이 공동으로 소유하고 유지하는 자료




### 데이터베이스의 특징

- 실시간 접근성 : 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 한다.
- 계속적인 변화 : 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다.
- 동시 공용 : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것으로 다수의 사용자가 같은 내용의 데이터를 이용할 수 있어야 한다.
- 내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 때, 사용자가 요구하는 데이터 내용으로 데이터를 찾는다.


### 데이터베이스 시스템

- **데이터베이스 시스템**이란 **데이터베이스를 이용하여 자료를 저장하고 관리하여 정보를 얻어내는 데 필요한 컴퓨터 중심의 시스템**

- ![데이터베이스시스템구성요소](./images/데이터베이스시스템구성요소.PNG)





## DBMS의 기능

### DBMS의 정의

- **DBMS**는 사용자와 데이터베이스 사이에서 **사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어**




### DBMS의 발전 배경

- 기존 방식(**파일 시스템**) : **처리 업무 하나하나마다 데이터 파일을 독립적으로 구성**함으로써, 같은 내용의 데이터가 서로 다른 업무의 파일에서 중복저장되어 관리되는 데이터 중복성, 데이터 종속성을 초래하는 단점 존재
- **데이터베이스** 도입 : **각 업무 처리에 필요한 자료들의 중복을 최소화하여 한 곳에 모아서 구성**




### 대표적인 DBMS

- 오라클 / Oracle : PC급에서 메인프레인급까지 모두 설치할 수 있으며, 분산 처리 지원 기능이 우수
- MySQL / MySQL AB : 다양한 플랫폼과 API를 지원하는 비상업용 DBMS





### DBMS의 필수 기능

- 정의(Definiton) 기능
  - 데이터베이스에 저장될 **데이터 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시
  - 데이터와 데이터의 관계를 명확하게 명세할 수 있어야 하며, 데이터 연산은 무엇이든 명세
  
- 조작(Manipulation) 기능
  - **데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리**하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
  
- 제어(Control) 기능
  - **데이터의 무결성 유지**
  - 정당한 사용자가 허가된 데이터만 접근할 수 있도록 **보안을 유지하고, 권한을 검사**
  - 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때, 처리결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있어야 한다.
  
  
  
  
### DBMS의 장단점

| <center>장점</center> |  <center>단점</center> |
|:----------------:|:----------------:|
| 데이터의 논리적, 물리적 독립성이 보장 | 전산화 비용이 증가 |
| 데이터의 중복을 피할 수 있어서 기억공간 절약 | 대용량 디스크로의 집중적인 Access로 과부하(Overhead) |
| 저장된 자료를 공동으로 이용 | 파일의 Backup과 Recovery가 어렵다 |
| 데이터의 일관성, 무결성, 보안 유지 | 시스템이 복잡 |
| 항상 최신의 데이터 유지, 데이터의 실시간 처리 가능 |  |

  - 백업(Back up) : 장비 고장 등의 비상사태에도 데이터베이스가 보존되도록 복사하는 작업





## 스키마(Schema)

### 스키마의 정의

- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specificaion)을 기술한 메타데이터 집합
- **스키마**는 **데이터베이스를 구성하는 개체(엔티티), 속성, 관계 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의**


  ![스키마3계층](./images/스키마3계층.PNG)




### 스키마의 특징

- 스키마는 **데이터 사전**에 저장되며, 다른 이름으로 **메타데이터**라고도 한다.
- 스키마는 시간에 따라 불변인 특성을 갖는다.
- 스키마는 데이터의 구조적 특성을 의미한다.




### 스키마의 3계층

- 데이터베이스의 관리 시스템은 외부적 스키마에 따라 명시된 사용자의 요구를 개념적 스키마에 적합한 형태로 변경하고 이를 다시 내부적 스키마에 적합한 형태로 변환한다.

  - 외부 스키마 (=사용자 뷰)
    - **외부 스키마**는 **사용자나 응용 프로그래머가 각 개인의 입장**에서 필요로 하는 데이터베이스의 논리적 구조를 정의
    - 일반 사용자는 질의어(SQL)를 이용하여 DB를 쉽게 사용할 수 있다.
    - 응용 프로그래머는 C, COBOL 등의 언어를 사용하여 DB에 접근한다.
    - 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있다.
  
  - 개념 스키마 (=전체적인 뷰)
    - **개념 스키마**는 **데이터베이스의 전체적인 논리적 구조**
    - 조직 전체의 데이터베이스로 하나만 존재
    - 개념 스키마는 **개체 간의 관계와 제약 조건을 나타내고, 접근 권한, 보안 및 무결성 규칙에 관한 명세**를 정의
  - 내부 스키마 (=저장 스키마)
    - **내부 스키마**는 **물리적 저장위치의 입장에서 본 데이터베이스 구조**
    - 내부 스키마는 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.
    - 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마
    
    



## 데이터베이스 언어

- 데이터베이스 언어는 데이터베이스를 구축하고 이용하기 위한 데이터베이스 시스템과의 통신 수단
- 데이터베이스 언어는 DBMS를 통해 사용하며, 기능과 사용 목적에 따라 데이터 정의 언어, 데이터 조작 언어, 데이터 제어 언어로 구분된다.


### 데이터 정의 언어 (DDL)

- DB구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어
- 외부 스키마를 정의



### 데이터 조작 언어 (DML)

- 사용자로 하여금 데이터를 처리할 수 있게 하는 도구로서, 사용자(응용 프로그램)과 DBMS 간의 인터페이스를 제공
- 응용 프로그램을 통해서 사용자가 DB의 데이터를 실질적으로 조작할 수 있도록 하기 위해 COBOL 등의 호스트 언어에 DB 기능을 추가해서 만든 언어

  - 질의어 : 단말 사용자가 쉽게 DB를 액세스할 수 있도록 대화식의 자연어로 만든 비절차적 조작 언어 EX) SQL
  - 비절차적 조작 언어 : 사용자가 어떤 데이터가 필요한지만 명시하고 어떻게 구하는 지 명시하지 않는 언어
  
  
  

### 데이터 제어 언어 (DCL)
    
- 무결성, 보안 및 권한 제어, 회복 등을 하기 위한 언어
- 데이터를 보호하고 데이터를 관리하는 목적으로 사용



## 데이터 모델의 개념

### 데이터 모델의 정의

- **데이터 모델**은 **현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화**하여 체계적으로 표현한 개념적 모형




### 데이터 모델의 구성 요소

- 개체 : 데이터베이스에 표현하려는 것 ex) 교수
- **속성** : **데이터의 가장 작은 논리적 단위**, 개체를 구성하는 항목 ex) 성명, 전공, 소속
- 관계 : 개체 간의 관계
    - 관계의 형태 : 1대1 관계, 1대N 관계, N대N 관계
    



## E-R다이어그램


### E-R다이어그램 개념

- 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 개체들을 표현
- E-R 다이어 그램 기호
  - ![ER다이어그램기호](./images/ER다이어그램기호.PNG)
  
  
- E-R 다이어 그램 예시
  - ![ER다이어그램예시](./images/ER다이어그램예시.PNG)
  
  
- 새발 표기법
  - 관계의 의미나 제약 조건 등을 개체 타입들을 연결하는 몇 가지 기호를 사용하여 표현하는 표기법
  - ![새발표기법](./images/새발표기법.PNG)
  
  
  - 새발표기법 예시
  - ![새발표기법예시](./images/새발표기법예시.PNG)
  
  
  
  
## 관계형 데이터 모델

### 관계형 데이터 모델의 개념

- 기본키와 이를 참조하는 외래키로 데이터 간의 관계를 표현
- 1:1, 1:N, M:N 관계를 자유롭게 표현




### E-R모델을 관계 모델의 테이블로 변환

- 개체 A,B와 관계 Y로 이루어진 E-R모델을 관계 테이블로 변환하는 방법
  - ![테이블변환](./images/테이블변환.jpg)
  
  
  - 개체를 독립적인 테이블로 표현
  - 관계 Y가 **1:1관계**이면 **개체 A의 기본키를 개체 B의 외래키로 추가**하거나 **개체 B의 기본키를 개체 A의 외래키로 추가**
  - 관계 Y가 **1:N관계**이면 **개체 A의 기본키를 개체 B의 외래키로 추가**하여 표현하거나 별도의 테이블로 표현
  - 관계 Y가 **M:N관계**이면 **개체 A와 B의 기본키를 모두 포함한 별도의 테이블**로 표현
  
  
  
### 관계형 데이터 모델의 특징

- 장점 : 간결하고, 보기 편리하고, 다른 데이터베이스로의 변환이 용이
- 단점 : 성능이 떨어진다.






## 데이터베이스 설계

### 데이터베이스 설계의 개념

- **데이터베이스 설계**란 **사용자의 요구를 분석**하여 그것들을 컴퓨터에 저장할 수 있는 **데이터베이스의 구조에 맞게 변경한 후 특정 DBMS로 데이터베이스를 구현**하여 일반 사용자들이 사용하게 하는 것




### 데이터베이스 설계 시 고려사항

- 무결성 : 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함
- 일관성 : 특정 질의에 대한 응답이 끝까지 변함없이 일정해야 함
- 회복 : 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함
- 보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호
- 효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함
- 데이터베이스 확장 : 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터베이스를 추가할 수 있어야 함




### 데이터베이스 설계 순서

- 요구 분석 > 개념적 설게 > 논리적 설계 > 물리적 설계 > 구현

 
    - 요구 조건 분석 : 수집된 정보(데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건)를 바탕으로 요구 조건 명세를 작성
    - 개념적 설계 : 개념 스키마 설계, 요구 분석 단계에서 나온 결과(요구 조건 명세)를 DBMS에 독립적인 E-R다이어그램으로 작성
    - 논리적 설계 : 개념 스키마를 평가 및 정재하고 DBMS에 따라 서로 다른 논리적 스키마를 설계, 테이블을 설계
    - 물리적 설계 : 디스크 등 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환, 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정
    
    
      - 물리적 설계 옵션 시 고려 사항
        - 반응 시간 : 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을 때까지의 경과 시간
        - 공간 활용도 : 데이터베이스 파일과 액세스 경로 구조에 의해 사용되는 저장공간의 양
        - 트랜잭션 처리량 : 단위시간 동안 데이터베이스 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수
        
    - 데이터베이스 구현 : DDL로 데이터베이스 생성, 트랜잭션 




## 관계형 데이터베이스의 구조

### 관계형 데이터베이스의 릴레이션 구조

- ![관계형데이터베이스릴레이션구조](./images/관계형데이터베이스릴레이션구조.PNG)


- 튜플(Tuple) : 릴레이션을 구성하는 각각의 행, 파일 구조에서 레코드와 같은 의미
  - **튜플의 수** : **카디날리티**
  
- 속성(Attribute) : 데이터베이스를 구성하는 가장 작은 논리적 단위
  - **속성의 수** : 디그리, 차수
  
- 도메인 : 하나의 속성(Attribute)이 취할 수 있는 같은 타입의 원자값들의 집합
  - ex) 성별 애트리뷰트의 도메인은 '남'과 '여'로, 그 외의 값은 입력될 수 없다.
  > 도메인의 역할 : 데이터베이스에 입력되는 자료의 오류를 방지하기 위해 필요
  
  
  
### 릴레이션의 특징

- 한 릴레이션에는 똑같으 튜플이 포함될 수 없다.
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 지정한다. ex) '학년'에 저장된 1,2,3은 더 이상 세분화 X




## 관계형 데이터베이스의 제약 조건

### 제약 조건이란?

- 데이터베이스에 저장되는 데이터의 정확성을 보장하기 위해서 키를 이용하여 입력되는 데이터에 제한을 주는 것
- ex) 개체 무결성 제약, 참조 무결성 제약 등



### 키의 개념 및 종류

- **키(Key)** : 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 **튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트**

- **유일성** : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
- **최소성** : 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 한다.

  - 후보키 : 기본키로 사용할 수 있는 속성들, 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.
  - 기본키 : 특정 튜플을 유일하게 구별할 수 있는 속성, NULL값 가질 수 없음, 동일한 값 중복 X
    - ex) <학생>릴레이션에서는 '학번', '주민번호'가 기본키가 될 수 있다.
  - 대체키 : 후보키가 둘 이상일 때, 기본키를 제외한 후보키
  - 슈퍼키 : 모든 튜플들에 대해서 유일성은 만족시키지만, 최소성은 만족시키지 못한다.
    - ex) <학생>릴레이션에서는 '학번', '주민번호', '학번+주민번호', '주민번호+성명', '학번+주민번호+성명' 등으로 슈퍼키를 구성할 수 있다.
    
  - 외래키 : 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는 키
  
  
  
### 무결성

- **개체 무결성** : 릴레이션에서 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없다.
- **참조 무결성** : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다.




## 정규화

### 정규화란

- **정규화** : 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 좀 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정

- 정규화는 데이터베이스의 논리적 설계 단계에서 수행한다.
- 정규화는 논리적 처리 및 품질에 큰 영향을 미친다.




### 정규화 목적

- 데이터 구조의 안정성을 최대화한다.
  - 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다.
  - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
- 효과적인 검색 알고리즘을 생성할 수 있다.



### 함수 종속

- X가 Y를 결정한다. X는 Y의 결정자
- X : 결정자, Y : 종속자


- ![함수종속예제](./images/함수종속예제.png)

- ex) {학번, 과목번호} -> {성적} : 완전 함수 종속
- ex) {학번} -> {학년} : 부분 함수 종속




### 이상의 개념 및 종류

- **이상** : 정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생
- ex) 삽입 이상, 삭제 이상, 갱신 이상 등


  - 삽입 이상 : 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상
  - 삭제 이상 : 한 튜플을 삭제할 때 의도와는 상과없이 원하지 않는 값들도 함께 삭제되는 현상
  - 갱신 이상 : 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상




### 정규화 과정

- 일반적으로 데이터베이스를 설계할 때에는 BCNF까지만 고려
  > 정규화 과정을 거칠수록 join 연산으로 인한 성능저하를 가져올 수 있기 때문에
  > 단계 진행할수록 데이터의 무결성을 우선으로 할 지 데이터베이스 구성의 단순화와 성능을 우선으로 할 지를 결정
  
  
- ![정규화과정](./images/정규화과정.png)


  - 제1정규형 (1NF) : 어떤 릴레이션 R에 속한 모든 도메인이 원자값만으로 되어 있다.
  
  - ![제1정규화](./images/제1정규화.PNG)
  
  - 제2정규형 (2NF) : 어떤 릴레이션 R이 제 1정규형이고, 키에 속하지 않는 속성 모두가 키에 완전 함수 종속 : 무손실분해
  
  - ![제2정규화](./images/제2정규화.PNG)
  - ![제2정규화2](./images/제2정규화2.PNG)
  
    > 학번은 혼자 스스로 잘할 수 있지만, 과목명은 혼자 스스로 잘할 수 없으니까 학번이랑 같이 있어야함.
    
    
  - 제3정규형 (3NF) : 어떤 릴레이션 R이 2NF이고, 모든 속성들이 기본키에 이행적 함수 종속이 아닌 경우
    - 이행적 함수 종속성 : A->B와 B->C의 함수 종속성이 존재하면 A->C (속성 C가 이행적으로 A에 종속)
    
  - ![제3정규화](./images/제3정규화.PNG)
  
  - ![제3정규화2](./images/제3정규화2.PNG)
  
    > 결정자 X -> 종속자 Y : 결정자 X가 개수가 더 많다고 생각했더니 이해가 되었다. X가 Y에 포함이 되는 경우.
   
  
  - BCNF : 릴레이션 R이 제 3정규형이고, 모든 결정자가 후보키이어야 한다.
  
  - ![BCNF](./images/BCNF.PNG)
  
  - ![BCNF2](./images/BCNF2.PNG)
  
  
## SQL

### SQL이란?

- 질의어지만 질의 기능만 가지고 있는 것이 아니라 데이터 구조의 정의, 데이터 조작, 데이터 제어 기능을 모두 갖추고 있다.
  > 질의어 : 단말 사용자들이 쉽게 DB를 이용할 수 있도록 되어 있는 비절차어의 일종
  
  
### SQL의 분류

- DDL (데이터 정의어)
  - CREATE
    
    - CREATE SCHEMA (스키마 정의)
    ```sql
    
    // 소유권자의 사용자 ID가 홍길동인 스키마 '대학교' 정의문
    CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;
    
    ```

    - CREATE DOMAIN (도메인 정의)
    ```sql
    
    // '남', '여' 또는 '?'중의 한 문자를 취할 수 있는 도메인 SEX의 정의문
    CREATE DOMAIN SEX CHAR(1) // 정의된 도메인 이름은 'SEX'이며, 크기는 1자 
      DEFAULT '여' // 기본값 '여'
      CONSTRAINT VALID-SEX CHECK(VALUE IN ('남', '여', '?'));   //  3개의 값 중 하나만 취하도록 제한
    
    ```
    
    - CREATE TABLE (테이블 정의)
    
    ```sql
    
    CREATE TABLE 학생
      (이름 VARCHAR(15) NOT NULL,
      학번 VARCHAR(15) NOT NULL,
      전공 VARCHAR(15) NOT NULL,
      성별 SEX,   // 앞에서 정의한 도메인
      생년월일 DATE,
      PRIMARY KEY(학번),
      FOREIGN KEY(전공) REFERENCES 학과(학과코드),  // '전공'은 '학과' 테이블의 '학과코드' 속성을 참조하는 외래키
      CONSTRAINT 성별제약 CHECK (성별='남')         // '성별' 속성의 값으로 '남'만 저장할 수 있게 제약
      );
    
    ```
    
    - CREATE INDEX (인덱스 정의)
    
    ```sql
    
    // '고객' 테이블의 기본키인 '고객번호' 속성에 대해 오름차순 정렬하여 '고객번호_INX'라는 이름으로 인덱스 구성
    
    CREATE UNIQUE INDEX 고객번호_INX
      ON 고객(고객번호 ASC);
    
    ```
    
  - ALTER
  
    - ALTER TABLE (테이블 정의 변경)
    
    ```sql
    
    // '학생' 테이블에 최대 3문자로 구성되는 '학년'속성 추가
    
    ALTER TABLE 학생 ADD 학년 VARCHAR(3);
    
    ```
    
  - DROP
  
    - DROP TABLE (테이블 삭제)
    > CASCADE : 삭제할 요소를 참조하는 다른 모드 개체 함께 삭제
    > RESTRICTED : 삭제할 요소를 다른 개체가 참조중일 때 삭제 취소
    
    ```sql
    
    // '학생' 테이블을 삭제하되, '학생' 테이블을 참조하는 모든 테이블을 함께 삭제
    DROP TABLE 학생 CASCADE;
    
    ```
  

- DML

  - SELECT
    - 일반 형식
    > ASC : 오름차순
    > DESC : 내림차순
    > 생략시 오름차순
    
    ```sql
    
    SELECT [DISTINCT] 속성명
    FROM 테이블명
    WHERE 조건
    GROUP BY 속성명
    HAVING 조건
    ORDER BY 속성명 [ASC|DESC];
    
    ```
  
    ```sql
    
    // <사원> 테이블에서 주소만 검색하되 같은 주소는 한 번만 출력
    SELECT DISTINCT 주소 FROM 사원;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 기본급에 특별수당 10을 더한 월급을 "XX부서의 XXX의 월급 XXX"형태로 출력
    SELECT 부서, "부서의", 이름, "의 월급", 기본급+10 FROM 사원
    
    // 신기한 건 "부서의", "의 월급"이 사이 사이에 위치한다. 튜플마다 전부!
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 성이 '김'인 사람의 튜플을 검색
    SELECT * FROM 사원 WHERE 이름 LIKE "김%";
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 생일이 '01/09/69'에서 '10/22/73' 사이인 튜플을 검색
    SELECT * FROM 사원 WHERE 생일 BETWEEN #01/09/69# AND #10/22/73#;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 주소가 NULL인 튜플을 검색
    SELECT * FROM 사원 WHERE 주소 IS NULL;
    
    ```
    
    ```sql
   
     // <사원> 테이블에서 특정 인덱스 몇명을 검색
     SELECT * FROM 사원 LIMIT [시작할 로우 0부터 시작], [보여줄 개수];
   
     ex) SELECT * FROM 사원 LIMIT 32, 3; // 32번 인덱스부터 3명 보여주기
   
    ```
    
    ```sql
    
    // <사원> 테이블에서 주소를 기준으로 오름차순 정렬시켜서 상위 2개의 튜플만 검색
    SELECT TOP 2 * FROM 사원 ORDER BY 주소 ASC;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 부서별 기본급의 평균
    SELECT 부서, AVG(기본급) AS 평균
    FROM 사원 GROUP BY 부서;
    
    ```
    
    
    ```sql
    
    // <사원> 테이블에서 기본급이 100 이상인 사원이 2명 이상인 부서의 튜플 수
    SELECT 부서, COUNT(*) AS 사원수
    FROM 사원
    WHERE 기본급 >= 100
    GROUP BY 부서
    HAVING COUNT(*)>=2;
    
    ```
    
    ```sql
    
    // 취미가 '나이트댄스'인 사원의 이름과 주소를 검색
    SELECT 이름, 주소 FROM 사원
    WHERE 이름 = (SELECT 이름 FROM 여가활동 WHERE 취미='나이트댄스');
    
    ```
    
    ```sql
    
    // 취미활동을 하지 않는 사원들을 검색
    SELECT * FROM 사원
    WHERE 이름 NOT IN (SELECT 이름 FROM 여가활동)
    
    ```
    
    ```sql
    
    // 경력이 10년 이상인 사원의 이름, 부서, 취미, 경력을 검색
    SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력
    FROM 사원, 여가활동
    WHERE 여가활동.경력>=10 AND 사원.이름=여가활동.이름;
    
    ```
    
    ```sql
    
    // <사원>테이블과 <직원>테이블을 통합하는 질의문
    SELECT * FROM 사원
    UNION
    SELECT * FROM 직원;
    
    ```
    
    
  - INSERT
  
    ```sql
    
    // <사원> 테이블에 (이름-홍승현, 부서-인터넷)을 삽입하시오
    INSERT INTO 사원(이름, 부서) VALUES ('홍승현', '인터넷');
    
    ```
    
    ```sql
    
    // <사원> 테이블에 (장보고, 기획, 05/03/73, 석사동, 90)을 입력하시오
    INSERT INTO 사원 VALUES ('장보고', '기획', #05/03/73#, '석사동', 90);
    
    ```
    
    ```sql
    
    INSERT INTO 편집부원(이름, 생일, 주소, 기본급)
    SELECT 이름, 생일, 주소, 기본급
    FROM 사원
    WHERE 부서='편집';
    
    ```
    
  - UPDATE
  
    ```sql
    
    // <사원> 테이블에서 홍길동의 주소를 퇴계동으로 수정
    UPDATE 사원 SET 주소 = '퇴계동' WHERE 이름 = '홍길동';
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 황진이의 부서를 기획부로 변경하고 기본급을 5만우너 인상
    UPDATE 사원 SET 부서='기획', 기본급=기본급+5
    WHERE 이름='황진이';
    
    ```
    
  - DELETE
    
    ```sql
    
    // <사원> 테이블의 모든 레코드를 삭제
    DELETE FROM 사원;
    
    ```
    
    ```sql
    
    // <사원> 테이블에서 임꺽정에 대한 튜플을 삭제
    DELETE FROM 사원 WHERE 이름 = '임껵정';
    
    ```
    
    
- DCL
  - COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알린다.
  - ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구한다.
  - GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.
  - REVOKE : 데이터베이스 사용자의 사용 권한을 취소한다.
  
  
## 뷰 (View)

### 뷰란?

- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가진 가상 테이블

- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게 있는 것처럼 간주


### 뷰의 장단점

- 장점
  - 사용자의 데이터 관리 간단화
  - 접근 제어를 통한 자동 보안 제공
  - 논리적 데이터 독립성을 제공
  
- 단점
  - 독립적인 인덱스를 가질 수 없다
  - 뷰의 정의를 변경할 수 없다
  - 뷰로 구성된 애용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다
  
  

### 뷰의 정의 및 삭제문

- 정의

  ```sql
  // 고객테이블에서 주소가 춘천시인 고객들의 성명과 전화번호로 '춘천고객'이라는 뷰 정의
  
  CREATE VIEW 춘천고객(성명, 전화번호)
  AS SELECT 성명, 전화번호
  FROM 고객
  WHERE 주소='춘천시'
  ```
  
  
- 삭제
  ```sql
    
    // 뷰 '춘천고객'을 삭제하시오. 단 다른 곳에서 참고하고 있으면 제거되지 않게 하시오.
    DROP VIEW 춘천고객 RESTRICT;
    
    ```



## 시스템 카탈로그

### 시스템 카탈로그란?
- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 데이터 정의어의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 패키지, 접근 권한 등의 데이터베이스 구조 및 통계 정보를 저장
- 카탈로그에 저장된 정보를 메타 데이터라고 한다.
- 카탈로그는 DBMS가 스스로 생성하고 유지한다.
- 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신한다.
  
  
### 트랜잭션 처리기

- DBMS 내의 모듈 시스템
- 복수 사용자 환경에서 평행으로 동시에 일어나는 트랜잭션 문제를 해결하여, 각각의 사용자가 데이터베이스 자원을 배타적으로 이용할 수 있도록 한다.
  










## 데이터베이스의 성능

- 데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다.
  - 디스크 I/O란, 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.
  - 디스크의 성능은 디스크 헤더의위치를 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.
  
 - 그렇기 때문에 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분이 랜덤 I/O이다.
 - 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
 
 
 
 
 




